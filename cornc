#!/usr/bin/python3

# Cornlang (codenamed "Metal") parser, tokenizer and lexer.

import argparse
import copy
import json
import os
import pickle
import shutil
import sys
import traceback
from inspect import getframeinfo, stack

import bson


def debuginfo(message, depth=2):
    caller = getframeinfo(stack()[depth][0])
    # python3 syntax print
    print("%s:%d - %s" % (caller.filename, caller.lineno, message))
    # print(getframeinfo(stack()[2][0]))


DEVMODE = True

# SEMVER UPDATE
# ONLY ON DEV MODE

if DEVMODE:
    try:
        if open(sys.argv[0].strip('./') + '.old').readlines() != open(sys.argv[0].strip('./')).readlines():
            print(
                "Incrementing patch number by 1. If this is wrong, please manually correct .semver file.")
            with open(sys.argv[0].strip('./') + '.semver', 'r') as svfile:
                tx = '\n'.join(svfile.readlines())
                print(tx)
                major = int(tx.split('.')[0])
                minor = int(tx.split('.')[1])
                patch = int(tx.split('.')[2])
                open(sys.argv[0].strip(
                    './') + '.semver', 'w').write(str(major) + '.' + str(minor) + '.' + str(patch + 1))
    except Exception as e:
        open(sys.argv[0].strip('./') + '.old',
             'w').write(''.join(open(sys.argv[0]).readlines()))
        print("Please run me again")
        exit(-1)
    open(sys.argv[0].strip('./') + '.old',
         'w').write(''.join(open(sys.argv[0]).readlines()))


def compile_program(program, saveprefix):
    print("\n\n\nCompiling", program)
    save_prefix_comp = saveprefix + '/' + program + '/'
    os.makedirs(save_prefix_comp)

    fcon = -1
    with open(program, 'r') as lang:
        fcon = lang.readlines()

    def check_id_constraints(var, c):
        retval = c.isalpha() or c == '_'
        if var != "":
            retval |= c.isnumeric()
        return retval

    tokens = []

    for line in fcon:
        line = line.strip()

        # identifier
        fullid = ""

        # number
        fullnum = 0
        number_base = -1  # not used
        number_char = -1  # not used

        # string
        in_string = False
        fullstr = ""
        is_escaping = False

        # symbol
        fullsym = ""

        # comment
        is_comment = False

        for c in line + ' ':  # make the loop go one more time after line ends
            if is_comment:
                break
            oldfullsym = fullsym
            if in_string:
                if c == '"' and not is_escaping:
                    in_string = False
                    tokens.append({'token': fullstr, 'type': 'str'})
                elif c == '\\' and not is_escaping:
                    is_escaping = True
                else:
                    fullstr += c
                    is_escaping = False
            else:
                if check_id_constraints(fullid, c):
                    fullid += c
                else:
                    if fullid != "":
                        tokens.append({'token': fullid, 'type': 'identifier'})
                    fullid = ""

                    if c.isnumeric():
                        fullnum = fullnum * 10 + int(c)
                        number_char += 1
                        if number_char == 0:
                            number_base = 10
                    else:
                        if number_char > -1:
                            tokens.append({'token': fullnum, 'type': 'number'})
                        number_char = -1
                        fullnum = 0

                        if c == '"':
                            in_string = True
                            fullstr = ""
                        elif c in ['(', ')', '[', ']', '{', '}']:
                            tokens.append({'token': c, 'type': 'bracket'})
                        # elif c == '$':
                        #     tokens.append({'token': c, 'type': 'formatter'})
                        # elif c in ['+', '-', '*', '/', '^', '~', '%', '!']:
                        #     tokens.append({'token': c, 'type': 'math'})
                        elif c == ';':
                            tokens.append({'token': c, 'type': 'semi'})
                        elif c == ',':
                            tokens.append({'token': c, 'type': 'sep'})
                        elif c == '#':
                            is_comment = True
                        else:
                            if not c.isspace():
                                # is symbol
                                fullsym += c
            if oldfullsym == fullsym:  # we haven't added a token somewhere
                if not fullsym.isspace() and fullsym != '':
                    tokens.append({'token': fullsym, 'type': 'sym'})
                    fullsym = ""

    # tokenization done, time for lexing!

    errors = []

    OPERATIONS = ['+', '-', '*', '/', '>', '<', '==', '<=', '>=', '&&', '||', '&', '|', '^', '!=']

    def error_out():
        if(len(errors) > 0):
            print("\n".join(errors))
            print("Dumping ast to " + save_prefix_comp + "ast_err.json")
            open(save_prefix_comp + "ast_err.json", "w").write(json.dumps(
                ast, indent=2, sort_keys=False))  # debug
            exit(-1)

    ast = {
        'globals': {}
    }

    def set_ast_scope(scope, val):
        nscope = copy.copy(scope)
        # print("scope:", nscope, "ast:", ast)
        cur_d = ast
        for v in scope[:-1]:
            if type(cur_d) is dict:
                cur_d.setdefault(v, {})
            cur_d = cur_d[v]
        cur_d[scope[-1]] = val

    def append_ast_scope(scope, val):
        nscope = scope
        # print("scope:", nscope, "ast:", ast)
        cur_d = ast
        for v in nscope[:-1]:
            if type(cur_d) is dict:
                cur_d.setdefault(v, {})
            cur_d = cur_d[v]
        cur_d[nscope[-1]].append(val)

    def get_ast_scope(scope):
        accumulator = copy.copy(ast)
        for elem in scope:
            accumulator = accumulator[elem]
        return accumulator

    # returns itt after incrementing - itt should point to the first opening curly bracket

    def lex_scope(scope, itt, entr='{}', is_argp=0):

        def incr_itt(cnt=1):
            nonlocal itt
            itt += cnt
            if itt >= len(tokens):
                errors.append("Premature end-of-file detected, terminating...")
                error_out()

        scope_checker = 1 if is_argp != 0 else 0

        last_seen_op = -1

        itt_entr = copy.copy(itt)

        print("CHECK SCOPE =>", scope, "itt", itt +
              1, "symbol", tokens[itt + 1]["token"], "parsemode", is_argp)
        debuginfo("Scope call location")
        while True:
            incr_itt()  # get next token
            # print("CURRENT TOKEN =>", tokens[itt], "ITT", itt, "ENTR", entr)
            # debuginfo("Scope call location")
            # print("scope", scope, "itt", itt, "char", tokens[itt]["token"])
            token = tokens[itt]
            if token["type"] == 'identifier':
                if token["token"] in ["if", "while", "foreach"]:
                    append_ast_scope(scope, {
                        'act': 'statement',
                        'name': token["token"],
                        'args': [],
                        'body': []
                    })

                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    while tokens[itt]["token"] != ')':
                        itt = lex_scope(new_scope, itt, '()', True)

                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'body']
                    itt = lex_scope(copy.copy(new_scope), itt)
                elif token["token"] == 'ptr':
                    incr_itt()
                    append_ast_scope(scope, {
                        'act': 'varop',
                        'name': token["token"],
                        'var': tokens[itt]["token"]
                    })
                elif token["token"] in ['return', 'deref', 'not', 'destroy']:
                    append_ast_scope(scope, {
                        'act': 'statement',
                        'name': token["token"],
                        'args': []
                    })

                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()', True)
                elif token["token"] in ["var", "glvar"]:  # variable definition
                    # incr_itt()
                    # var_type = tokens[itt]["token"]
                    # incr_itt()
                    # incr_itt()
                    # variable declarations and definitions should only contain =
                    # if tokens[itt]["token"] in ["="]:
                    append_ast_scope(scope, {
                        'act': token["token"] + 'def',
                        'name': '',
                        'args': [],
                        'type': []
                    })
                    new_scope_t = scope + [len(get_ast_scope(scope)) - 1, 'type']
                    itt = lex_scope(new_scope_t, itt, '()', 3)
                    # itt -= 2
                    og_scope = get_ast_scope(scope + [len(get_ast_scope(scope)) - 1])
                    og_scope["name"] = tokens[itt + 1]["token"]

                    incr_itt()
                    incr_itt()

                    set_ast_scope(scope + [len(get_ast_scope(scope)) - 1], og_scope)
                    new_scope = scope + \
                        [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()', 2)
                elif token["token"] in ["ptrvar", "lstvar"]:
                    lst_len = -1
                    if token["token"] == "lstvar":
                        incr_itt()
                        lst_len = tokens[itt]["token"]
                    append_ast_scope(scope, {
                        'act': 'statement',
                        'name': token["token"],
                        'len': lst_len,
                        'type': []
                    })
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'type']
                    itt = lex_scope(new_scope, itt, '()', 3)
                    break
                elif token["token"] in ["str", "i7", "i6", "i5", "i4", "i3", "i2", "i1", "i0"]:
                    append_ast_scope(scope, {
                            'act': 'type',
                            'type': token["token"],
                        })
                    break
                elif token["token"] == "lst":
                    incr_itt()
                    arr_type = tokens[itt]["token"]
                    incr_itt()
                    arr_name = tokens[itt]["token"]
                    incr_itt()
                    # variable declarations and definitions should only contain =
                    if tokens[itt]["token"] in ["="]:
                        append_ast_scope(scope, {
                            'act': 'lstdef',
                            'type': arr_type,
                            'name': arr_name,
                            'args': [],
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'args']
                        itt = lex_scope(new_scope, itt, '()', 2)
                    else:
                        errors.append(
                            "Could not parse list variable declaration")
                elif token["token"] == "fun":  # function definition
                    incr_itt()
                    function_name = tokens[itt]["token"]
                    if tokens[itt]["type"] != "identifier":
                        errors.append("Expected identifier as function name, got {}".format(
                            tokens[itt]["type"]))
                    incr_itt()
                    function_arguments = []
                    function_return = ""
                    while tokens[itt]["token"] != '=>':
                        if tokens[itt]["token"] == ',':
                            incr_itt()
                            continue
                        arg_name = tokens[itt]["token"]
                        incr_itt()
                        if tokens[itt]["token"] != ':':
                            errors.append("Expected seperator in function argument '{}': did you mean to call {}?".format(
                                arg_name, function_name))
                        incr_itt()
                        arg_type = tokens[itt]["token"]
                        incr_itt()
                        function_arguments.append(
                            {'name': arg_name, 'type': arg_type})  # no need to lex this recursively
                    incr_itt()
                    function_return = tokens[itt]["token"]

                    set_ast_scope(scope + [function_name], {
                        'name': function_name,
                        'act': 'fundef',
                        'args': function_arguments,
                        'return': function_return,
                        'body': []
                    })

                    new_scope = scope + [function_name, 'body']
                    itt = lex_scope(copy.copy(new_scope), itt)

                    # print("FUNCTION => ", function_name,
                    #       function_arguments, function_return, "itt:", itt)
                elif token["token"] == "ext":
                    incr_itt()
                    ext_name = tokens[itt]["token"]
                    incr_itt()
                    ext_args = []
                    while tokens[itt]["token"] != '=>':
                        ext_args.append(tokens[itt]["token"])
                        incr_itt()
                    incr_itt()
                    return_type = tokens[itt]["token"]
                    set_ast_scope(scope + [ext_name], {
                        'name': ext_name,
                        'act': 'extdef',
                        'args': ext_args,
                        'return': return_type
                    })
                elif token["token"] == "glb":
                    incr_itt()
                    v_type = tokens[itt]["token"]
                    incr_itt()
                    var_name = tokens[itt]["token"]
                    incr_itt()
                    if tokens[itt]["token"] in ["="]:
                        set_ast_scope(scope + [var_name], {
                            'name': var_name,
                            'type': v_type,
                            'act': 'glbdef',
                            'body': []
                        })
                        new_scope = scope + \
                            [var_name, 'body']
                        itt = lex_scope(new_scope, itt, '()', 2)
                    else:
                        errors.append(
                            "Could not parse global variable declaration")
                elif tokens[itt + 1]["token"] == "(":  # function call
                    self_function = tokens[itt - 1]["token"] == '.'
                    selfarg = ""
                    if self_function:
                        selfarg = get_ast_scope(
                            scope)[len(get_ast_scope(scope)) - 1]
                        set_ast_scope(scope, get_ast_scope(scope)[:-1])
                    # print("{}FUNCTION CALL".format(
                    #     "SELF " if self_function else ""), token["token"])
                    append_ast_scope(scope, {
                        'act': 'call',
                        'name': token["token"],
                        'args': [selfarg] if self_function else []
                    })
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    while tokens[itt]["token"] != ')':
                        itt = lex_scope(new_scope, itt, '()', True)
                else:  # should be a variable
                    # are we getting or setting?
                    incr_itt()
                    # TODO: account for & and | and ^ and **
                    if tokens[itt]["token"] in ['=', "+=", "-=", "/=", "*="]:
                        tkn_ss = tokens[itt]["token"]
                        tkn_nm = tokens[itt - 1]["token"]
    
                        if tkn_ss == '=':
                            append_ast_scope(scope, {
                                'act': 'varset',
                                'name': tokens[itt - 1]["token"],
                                'oper': '=',
                                'args': [],
                            })
                            new_scope = scope + \
                                [len(get_ast_scope(scope)) - 1, 'args']
                            itt = lex_scope(new_scope, itt, '()', 2)
                        else:
                            append_ast_scope(scope, {
                                'act': 'varset',
                                'name': tokens[itt - 1]["token"],
                                'oper': '=',
                                'args': [
                                    {
                                        'act': 'oper',
                                        'val': tkn_ss[0],
                                        'args': [
                                            {
                                                "act": "getvar",
                                                "name": tkn_nm
                                            }
                                        ]
                                    }
                                ],
                            })
                            new_scope = scope + \
                                [len(get_ast_scope(scope)) - 1, 'args', 0, 'args']
                            itt = lex_scope(new_scope, itt, '()', 2)
                    else:  # getting
                        # print("GETVAR", itt)
                        itt -= 1
                        append_ast_scope(scope, {
                            'act': 'getvar',
                            'name': token["token"]
                        })
            elif token["type"] == 'number':
                append_ast_scope(scope, {
                    'act': 'const',
                    'type': 'number',
                    'val': token["token"]
                })
            elif token["type"] == 'str':
                append_ast_scope(scope, {
                    'act': 'const',
                    'type': 'str',
                    'val': token["token"]
                })
            elif token["type"] == 'bracket':
                # print("bracket itt", itt, "char", tokens[itt]["token"])
                # print("entr", entr)
                if token["token"] == '(':
                    # print("itt_entr", itt_entr, "itt", itt, token)
                    if itt_entr + 1 != itt:
                        # print("well, going in!")
                        append_ast_scope(scope, {
                            'act': 'expr',
                            'val': []
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'val']
                        itt = lex_scope(new_scope, itt - 1, '()')
                    else:
                        # print(
                        #     "not going in, this is the reason we came here in the first place")
                        pass
                elif token["token"] == '[':
                    if tokens[itt - 1]["type"] == 'sym':  # we are defining an array
                        append_ast_scope(scope, {
                            'act': 'arrset',
                            'args': []
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'args']
                        while tokens[itt]["token"] != ']':
                            itt = lex_scope(new_scope, itt, '[]', True)
                    else:  # we are indexing an array
                        old_stat_place = get_ast_scope(
                            scope + [len(get_ast_scope(scope)) - 2])
                        set_ast_scope(scope, get_ast_scope(scope)[:-1])
                        append_ast_scope(scope, {
                            'act': 'arrget',
                            'body': [old_stat_place],
                            'args': []
                        })

                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'args']
                        itt = lex_scope(new_scope, itt, '[]', True)
                elif token["token"] == entr[1]:
                    # scope_checker -= 1
                    # if scope_chnew_scope_setecker == 0:
                    #     break  # break out of the loop, scope end reached
                    print("END REACHED OF SCOPE", scope)
                    if(len(scope) == 3):
                        append_ast_scope(scope, {
                                'act': 'statement',
                                'name': 'return',
                                'args': []
                            })
                    break
                elif token["token"] == entr[0]:
                    scope_checker += 1
            elif token["type"] == 'sym':
                # TODO: add support for negative values
                if token["token"] in OPERATIONS:  # operation
                    if is_argp == 2:
                        last_seen_op = -1

                    currarg = get_ast_scope(
                        scope)[len(get_ast_scope(scope)) - 1]
                    set_ast_scope(scope, get_ast_scope(scope)[:-1])
                    append_ast_scope(scope, {
                        'act': 'oper',
                        'args': [
                            currarg
                        ],
                        'val': token["token"]
                    })
                    # print("check next argument itt", itt)
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()',
                                    True if is_argp == 0 else is_argp)
                    # itt -= 1
                    # print("Ended operation itt", itt, "char", tokens[itt]["token"])
            if is_argp != 0:
                # print("CHECK TOKEN IS", tokens[itt]["token"], token["token"],
                #       "ITT", itt, "is_argp", is_argp, "entr", entr)
                if tokens[itt]["token"] in [",", ".", ")"]:
                    break  # argument parsing done
            last_seen_op += 1
            if is_argp == 2:
                incr_itt()
                itt -= 1
                # print("Should I stop varset? itt", itt, "lastseen",
                #       last_seen_op, "nexttok", tokens[itt + 1]["token"])
                if tokens[itt + 1]["token"] not in OPERATIONS and tokens[itt]["token"] not in OPERATIONS:
                    # print("stopping")
                    break
            if is_argp == 3:
                if tokens[itt]["token"] in ["="]:
                    break
        # print("END SCOPE =>", scope, "itt", itt,
        #       "symbol", tokens[itt]["token"])
        return itt

    ti = -1

    tokens = [{'token': '{', 'type': 'bracket'}] + tokens
    tokens.append({'token': '}', 'type': 'bracket'})

    open(save_prefix_comp + "tokens.txt", "w").write("\n".join(["Token: {}\t\t\tType: {}".format(
        x["token"], x["type"]) for x in tokens]))  # debug

    try:
        lex_scope(['globals'], ti)
        error_out()
        open(save_prefix_comp + "ast.json", "w").write(json.dumps(
            ast, indent=2, sort_keys=False))  # debug

        # testing different file formats
        open(save_prefix_comp + "program.bson",
             "wb").write(bson.BSON.encode(ast))
        pickle.dump(ast, open(save_prefix_comp + "program.pck", "wb"))
    except Exception as e:
        traceback.print_exc()
        debuginfo("FUCKED UP", 3)
        print("Exception has occured:", e)
        print("Dumping ast to ast_err.json")
        open(save_prefix_comp + "ast_err.json", "w").write(json.dumps(
            ast, indent=2, sort_keys=False))  # debug


def run_program(program):
    prog_cnt = pickle.load(open(program, "rb"))
    print("\n\n\nRunning", program)

    DEFAULT_CONSTANTS = {
        'null': None,
        'true': True,
        'false': False,
    }

    def type_conversion(obj):
        if type(obj) is str:
            return "str"
        if type(obj) is int:
            return "i6"
        if type(obj) is bool:
            return "i0"
        if type(obj) is list:
            return "lst"

    def get_ast_scope(scope):
        accumulator = copy.copy(prog_cnt)
        for elem in scope:
            accumulator = accumulator[elem]
        return accumulator

    stop_function = False
    value_function = None

    var_arr = []
    glvar_arr = []

    def recursive_run(scope, vars_s={}, multiple_do="=", arg_parse=False):
        nonlocal stop_function
        nonlocal value_function
        instrs = get_ast_scope(scope)
        # print("APPENDING", vars_s, "TO VAR_ARR")
        # debuginfo("from")
        var_arr.append(vars_s)
        return_values = []
        return_value = None

        def set_var(name, value, op='='):
            v_index = get_var(name)["index"]
            if v_index == -1:
                v_index = len(var_arr) - 1
            if op == '=':
                var_arr[v_index][name] = value
            elif op == '+=':
                var_arr[v_index][name] += recursive_run(scope + [i, 'args'])
            elif op == '-=':
                var_arr[v_index][name] -= recursive_run(scope + [i, 'args'])
            elif op == '/=':
                var_arr[v_index][name] /= recursive_run(scope + [i, 'args'])
            elif op == '*=':
                var_arr[v_index][name] *= recursive_run(scope + [i, 'args'])
            else:
                var_arr[v_index][name] = recursive_run(
                    scope + [i, 'args'])  # this is an error but who cares

        def get_var(name):
            # print("var_arr", var_arr)
            for i, k in reversed(list(enumerate(var_arr))):
                # print("I:", i, "K", k)
                if name in k:
                    ret = {
                        'value': k[name],
                        'index': i
                    }
                    # print(ret)
                    return ret
            return {
                'value': None,
                'index': -1
            }

        def manage_return_value(value):
            nonlocal return_value
            if return_value != None:
                if multiple_do == '=':
                    return_value = value
                elif multiple_do == '+':
                    return_value += value
                elif multiple_do == '-':
                    return_value -= value
                elif multiple_do == '*':
                    return_value *= value
                elif multiple_do == '/':
                    return_value /= value
                elif multiple_do == '<':
                    return_value = value > return_value
                elif multiple_do == '>':
                    return_value = value < return_value
                elif multiple_do == '==':
                    return_value = value == return_value
                elif multiple_do == '>=':
                    return_value = value <= return_value
                elif multiple_do == '<=':
                    return_value = value >= return_value
                elif multiple_do == '&&':
                    return_value = value and return_value
                elif multiple_do == '||':
                    return_value = value or return_value
            else:
                return_value = value

        for i, instr in enumerate(instrs):
            # print("RUN INSTR", instr, "SCOPE", scope, "I", i, "vars", var_arr)
            if stop_function:
                if len(scope) == 3:
                    stop_function = False
                # explicity set this because we are returning from the function
                return_value = value_function
                break
            if instr["act"] == "vardef":
                # variable definitions return -1 because it is not allowed to chain variable definitions
                set_var(instr["name"], recursive_run(scope + [i, 'args']))
            elif instr["act"] == "glvardef":
                glvar_arr.append({
                    'name': instr["name"],
                    'value': recursive_run(scope + [i, 'args'])
                })
            elif instr["act"] == "lstdef":
                s_list = recursive_run(scope + [i, 'args'])
                if len(s_list) != 0:
                    if type_conversion(s_list[0]) != instr["type"]:
                        print("Error: List type not the same as variable type")
                set_var(instr["name"], s_list)
            elif instr["act"] == "varset":
                set_var(instr["name"], recursive_run(
                    scope + [i, 'args']), instr["oper"])
            elif instr["act"] == "const":
                manage_return_value(instr["val"])
            elif instr["act"] == "oper":
                # print("scope", scope, "val", instr["val"])
                manage_return_value(recursive_run(
                    scope + [i, 'args'], multiple_do=instr["val"]))
            elif instr["act"] == "call":
                function_args = recursive_run(
                    scope + [i, 'args'], arg_parse=True)  # 0 is selfarg
                if instr["name"] == "println":
                    print(function_args[0])
                elif instr["name"] == "print":
                    print(function_args[0], end="")
                elif instr["name"] == "fmt":
                    accum_str = function_args[0]
                    for fmt_i in range(1, len(function_args)):
                        accum_str = accum_str.replace(
                            '$' + str(fmt_i - 1), str(function_args[fmt_i]))
                    manage_return_value(accum_str)
                else:  # call non-builtin function
                    try:
                        if get_ast_scope(['globals', instr["name"], 'act']) == 'fundef':
                            args_list = [x["name"]
                                         for x in get_ast_scope(['globals', instr["name"], 'args'])]
                            vars_pass = {}
                            for iters, farg in enumerate(args_list):
                                vars_pass[farg] = function_args[iters]
                            manage_return_value(recursive_run(
                                ['globals', instr["name"], 'body'], vars_pass))
                        elif get_ast_scope(['globals', instr["name"], 'act']) == 'extdef':
                            manage_return_value(0)
                        else:
                            print(
                                "Error: You are trying to call a variable. Returning it instead.")
                            manage_return_value(get_var(instr["name"]))
                    except:
                        print(
                            "Error: You are possibly trying to call a variable. Returning it instead.")
                        manage_return_value(get_var(instr["name"])["value"])
            elif instr["act"] == "getvar":
                manage_return_value(get_var(instr["name"])["value"])
            elif instr["act"] == "expr":
                manage_return_value(recursive_run(
                    scope + [i, 'val'], arg_parse=True)[0])
            elif instr["act"] == "statement":
                stat_args = recursive_run(scope + [i, 'args'], arg_parse=True)
                if instr["name"] == "if":
                    if stat_args[0]:
                        recursive_run(scope + [i, 'body'])
                elif instr["name"] == "while":
                    # constantly check this
                    while recursive_run(scope + [i, 'args'], arg_parse=True)[0]:
                        recursive_run(scope + [i, 'body'])
                elif instr["name"] == "foreach":
                    for value in stat_args[0]:
                        recursive_run(scope + [i, 'body'],
                                      {stat_args[1]: value})
                elif instr["name"] == "return":
                    stop_function = True
                    value_function = stat_args[0] if len(
                        stat_args) > 0 else None
                    break
                elif instr["name"] == "ptr":
                    manage_return_value(next((i for i, item in enumerate(
                        glvar_arr) if item["name"] == stat_args[0]), None))
                elif instr["name"] == "deref":
                    manage_return_value(glvar_arr[stat_args[0]]["value"])
                elif instr["name"] == "not":
                    manage_return_value(not stat_args[0])
            elif instr["act"] == "arrset":
                arr_val = recursive_run(scope + [i, 'args'], arg_parse=True)
                type_acc = None
                for av in arr_val:
                    if(type_acc == None):
                        type_acc = type(av)
                    else:
                        if(type_acc == type(av)):
                            continue
                        else:
                            print("Error: Lists cannot contain mixed types.")
                            break
                manage_return_value(arr_val)
            elif instr["act"] == "arrget":
                manage_return_value(recursive_run(
                    scope + [i, 'body'])[recursive_run(scope + [i, 'args'], arg_parse=True)[0]])

            if arg_parse:
                return_values.append(return_value)

        var_arr.pop()
        return return_values if arg_parse else return_value

    for potential_global in prog_cnt["globals"]:
        if prog_cnt["globals"][potential_global]["act"] == "glbdef":  # defining global variable
            DEFAULT_CONSTANTS[potential_global] = recursive_run(
                ['globals', potential_global, 'body'])
    recursive_run(['globals', 'main', 'body'], DEFAULT_CONSTANTS)


cliargsparser = argparse.ArgumentParser(description="Corncomb (cornc for short) is an interpreter, tokenizer, lexical analyser and compiler for the language Cornlang", formatter_class=argparse.RawTextHelpFormatter)

cliargsparser.add_argument('act', help="The action to execute\n\tAvailable actions are:\n\t\ttest\n\t\trun\n\t\tast")
cliargsparser.add_argument('-f', '--file', help="Input filename")
cliargsparser.add_argument('-o', '--output', help="Output folder name")
cliargs = cliargsparser.parse_args()

if cliargs.act == 'test':
    if not cliargs.output:
        print("Wrong usage")
        exit(-1)
    saveprefix = cliargs.output
    programs = os.listdir('tests/')
    if os.path.isdir(saveprefix):
        shutil.rmtree(saveprefix)
    for program in programs:
        compile_program('tests/' + program, saveprefix)
    for program in programs:
        run_program(saveprefix + '/tests/' + program + '/program.pck')
elif cliargs.act == 'run':
    if not cliargs.output:
        print("Wrong usage")
        exit(-1)
    if not cliargs.file:
        print("Wrong usage")
        exit(-1)
    compile_program(cliargs.file, cliargs.output)
    run_program(cliargs.output + '/' + cliargs.file + '/program.pck')
elif cliargs.act == 'ast':
    if not cliargs.output:
        print("Wrong usage")
        exit(-1)
    if not cliargs.file:
        print("Wrong usage")
        exit(-1)
    compile_program(cliargs.file, cliargs.output)