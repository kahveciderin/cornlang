#!/usr/bin/python3

# Cornlang (codenamed "Metal") parser, tokenizer and lexer.

import copy
import traceback
import json
import bson
import pickle
import sys
import os
import shutil
from inspect import getframeinfo, stack


def debuginfo(message):
    caller = getframeinfo(stack()[2][0])
    # python3 syntax print
    print("%s:%d - %s" % (caller.filename, caller.lineno, message))
    # print(getframeinfo(stack()[2][0]))


DEVMODE = True

# SEMVER UPDATE
# ONLY ON DEV MODE

if DEVMODE:
    try:
        if open(sys.argv[0].strip('./') + '.old').readlines() != open(sys.argv[0].strip('./')).readlines():
            print(
                "Incrementing patch number by 1. If this is wrong, please manually correct .semver file.")
            with open(sys.argv[0].strip('./') + '.semver', 'r') as svfile:
                tx = '\n'.join(svfile.readlines())
                print(tx)
                major = int(tx.split('.')[0])
                minor = int(tx.split('.')[1])
                patch = int(tx.split('.')[2])
                open(sys.argv[0].strip(
                    './') + '.semver', 'w').write(str(major) + '.' + str(minor) + '.' + str(patch + 1))
    except Exception as e:
        open(sys.argv[0].strip('./') + '.old',
             'w').write(''.join(open(sys.argv[0]).readlines()))
        print("Please run me again")
        exit(-1)
    open(sys.argv[0].strip('./') + '.old',
         'w').write(''.join(open(sys.argv[0]).readlines()))

if len(sys.argv) < 2:
    print("Wrong usage")
    exit(-1)


def compile_program(program, saveprefix):
    print("\n\n\nCompiling", program)
    save_prefix_comp = saveprefix + '/' + program + '/'
    os.makedirs(save_prefix_comp)

    fcon = -1
    with open(program, 'r') as lang:
        fcon = lang.readlines()

    def check_id_constraints(var, c):
        retval = c.isalpha() or c == '_'
        if var != "":
            retval |= c.isnumeric()
        return retval

    tokens = []

    for line in fcon:
        line = line.strip()

        # identifier
        fullid = ""

        # number
        fullnum = 0
        number_base = -1  # not used
        number_char = -1  # not used

        # string
        in_string = False
        fullstr = ""
        is_escaping = False

        # symbol
        fullsym = ""

        # comment
        is_comment = False

        for c in line + ' ':  # make the loop go one more time after line ends
            if is_comment:
                break
            oldfullsym = fullsym
            if in_string:
                if c == '"' and not is_escaping:
                    in_string = False
                    tokens.append({'token': fullstr, 'type': 'str'})
                elif c == '\\' and not is_escaping:
                    is_escaping = True
                else:
                    fullstr += c
                    is_escaping = False
            else:
                if check_id_constraints(fullid, c):
                    fullid += c
                else:
                    if fullid != "":
                        tokens.append({'token': fullid, 'type': 'identifier'})
                    fullid = ""

                    if c.isnumeric():
                        fullnum = fullnum * 10 + int(c)
                        number_char += 1
                        if number_char == 0:
                            number_base = 10
                    else:
                        if number_char > -1:
                            tokens.append({'token': fullnum, 'type': 'number'})
                        number_char = -1
                        fullnum = 0

                        if c == '"':
                            in_string = True
                            fullstr = ""
                        elif c in ['(', ')', '[', ']', '{', '}']:
                            tokens.append({'token': c, 'type': 'bracket'})
                        # elif c == '$':
                        #     tokens.append({'token': c, 'type': 'formatter'})
                        # elif c in ['+', '-', '*', '/', '^', '~', '%', '!']:
                        #     tokens.append({'token': c, 'type': 'math'})
                        elif c == ';':
                            tokens.append({'token': c, 'type': 'semi'})
                        elif c == ',':
                            tokens.append({'token': c, 'type': 'sep'})
                        elif c == '#':
                            is_comment = True
                        else:
                            if not c.isspace():
                                # is symbol
                                fullsym += c
            if oldfullsym == fullsym:  # we haven't added a token somewhere
                if not fullsym.isspace() and fullsym != '':
                    tokens.append({'token': fullsym, 'type': 'sym'})
                    fullsym = ""

    # tokenization done, time for lexing!

    errors = []

    def error_out():
        if(len(errors) > 0):
            print("\n".join(errors))
            print("Dumping ast to " + save_prefix_comp + "ast_err.json")
            open(save_prefix_comp + "ast_err.json", "w").write(json.dumps(
                ast, indent=2, sort_keys=False))  # debug
            exit(-1)

    ast = {
        'globals': {},
        'body': {}
    }

    def set_ast_scope(scope, val):
        nscope = copy.copy(scope)
        # print("scope:", nscope, "ast:", ast)
        cur_d = ast
        for v in scope[:-1]:
            if type(cur_d) is dict:
                cur_d.setdefault(v, {})
            cur_d = cur_d[v]
        cur_d[scope[-1]] = val

    def append_ast_scope(scope, val):
        nscope = scope
        # print("scope:", nscope, "ast:", ast)
        cur_d = ast
        for v in nscope[:-1]:
            if type(cur_d) is dict:
                cur_d.setdefault(v, {})
            cur_d = cur_d[v]
        cur_d[nscope[-1]].append(val)

    def get_ast_scope(scope):
        accumulator = copy.copy(ast)
        for elem in scope:
            accumulator = accumulator[elem]
        return accumulator

    # returns itt after incrementing - itt should point to the first opening curly bracket

    def lex_scope(scope, itt, entr='{}', is_argp=0):

        def incr_itt(cnt=1):
            nonlocal itt
            itt += cnt
            if itt >= len(tokens):
                errors.append("Premature end-of-file detected, terminating...")
                error_out()

        scope_checker = 1 if is_argp != 0 else 0

        last_seen_op = -1

        itt_entr = copy.copy(itt)

        print("CHECK SCOPE =>", scope, "itt", itt +
              1, "symbol", tokens[itt + 1]["token"], "parsemode", is_argp)
        debuginfo("Scope call location")
        while True:
            incr_itt()  # get next token
            print("CURRENT TOKEN =>", tokens[itt], "ITT", itt, "ENTR", entr)
            debuginfo("Scope call location")
            # print("scope", scope, "itt", itt, "char", tokens[itt]["token"])
            token = tokens[itt]
            if token["type"] == 'identifier':
                if token["token"] == "if":  # if statement
                    append_ast_scope(scope, {
                        'act': 'statement',
                        'name': token["token"],
                        'args': [],
                        'body': []
                    })

                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()', True)

                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'body']
                    itt = lex_scope(copy.copy(new_scope), itt)
                elif token["token"] == "return":
                    append_ast_scope(scope, {
                        'act': 'statement',
                        'name': token["token"],
                        'args': []
                    })
                    
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()', True)
                elif token["token"] == "var":  # variable definition
                    incr_itt()
                    incr_itt()
                    # variable declarations and definitions should only contain =
                    if tokens[itt]["token"] in ["="]:
                        append_ast_scope(scope, {
                            'act': 'vardef',
                            'name': tokens[itt - 1]["token"],
                            'args': [],
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'args']
                        itt = lex_scope(new_scope, itt, '()', 2)
                    else:
                        errors.append("Could not parse variable declaration")
                elif token["token"] == "fun":  # function definition
                    incr_itt()
                    function_name = tokens[itt]["token"]
                    if tokens[itt]["type"] != "identifier":
                        errors.append("Expected identifier as function name, got {}".format(
                            tokens[itt]["type"]))
                    incr_itt()
                    function_arguments = []
                    function_return = ""
                    while tokens[itt]["token"] != '=>':
                        if tokens[itt]["token"] == ',':
                            incr_itt()
                            continue
                        arg_name = tokens[itt]["token"]
                        incr_itt()
                        if tokens[itt]["token"] != ':':
                            errors.append("Expected seperator in function argument '{}': did you mean to call {}?".format(
                                arg_name, function_name))
                        incr_itt()
                        arg_type = tokens[itt]["token"]
                        incr_itt()
                        function_arguments.append(
                            {'name': arg_name, 'type': arg_type})  # no need to lex this recursively
                    incr_itt()
                    function_return = tokens[itt]["token"]

                    set_ast_scope(scope + [function_name], {
                        'name': function_name,
                        'args': function_arguments,
                        'return': function_return,
                        'body': []
                    })

                    new_scope = scope + [function_name, 'body']
                    itt = lex_scope(copy.copy(new_scope), itt)

                    print("FUNCTION => ", function_name,
                          function_arguments, function_return, "itt:", itt)
                elif tokens[itt + 1]["token"] == "(":  # function call
                    self_function = tokens[itt - 1]["token"] == '.'
                    selfarg = ""
                    if self_function:
                        selfarg = get_ast_scope(
                            scope)[len(get_ast_scope(scope)) - 1]
                        set_ast_scope(scope, get_ast_scope(scope)[:-1])
                    print("{}FUNCTION CALL".format(
                        "SELF " if self_function else ""), token["token"])
                    append_ast_scope(scope, {
                        'act': 'call',
                        'name': token["token"],
                        'args': [selfarg] if self_function else []
                    })
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    while tokens[itt]["token"] != ')':
                        itt = lex_scope(new_scope, itt, '()', True)
                else:  # should be a variable
                    # are we getting or setting?
                    incr_itt()
                    # TODO: account for & and | and ^ and **
                    if tokens[itt]["token"] in ['=', "+=", "-=", "/=", "*="]:
                        print("SETVAR")
                        append_ast_scope(scope, {
                            'act': 'varset',
                            'name': tokens[itt - 1]["token"],
                            'oper': tokens[itt]["token"],
                            'args': [],
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'args']
                        itt = lex_scope(new_scope, itt, '()', 2)
                    else:  # getting
                        print("GETVAR", itt)
                        itt -= 1
                        append_ast_scope(scope, {
                            'act': 'getvar',
                            'name': token["token"]
                        })
            elif token["type"] == 'number':
                append_ast_scope(scope, {
                    'act': 'const',
                    'type': 'number',
                    'val': token["token"]
                })
            elif token["type"] == 'str':
                append_ast_scope(scope, {
                    'act': 'const',
                    'type': 'str',
                    'val': token["token"]
                })
            elif token["type"] == 'bracket':
                # print("bracket itt", itt, "char", tokens[itt]["token"])
                # print("entr", entr)
                if token["token"] == '(':
                    # print("itt_entr", itt_entr, "itt", itt, token)
                    if itt_entr + 1 != itt:
                        # print("well, going in!")
                        append_ast_scope(scope, {
                            'act': 'expr',
                            'val': []
                        })
                        new_scope = scope + \
                            [len(get_ast_scope(scope)) - 1, 'val']
                        itt = lex_scope(new_scope, itt - 1, '()')
                    else:
                        print(
                            "not going in, this is the reason we came here in the first place")
                elif token["token"] == '[':
                    if tokens[itt - 1]["type"] == 'sym': # we are defining an array
                        append_ast_scope(scope, {
                            'act': 'arrset',
                            'args': []
                        })
                        new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                        while tokens[itt]["token"] != ']':
                            itt = lex_scope(new_scope, itt, '[]', True)
                    else: # we are indexing an array
                        old_stat_place = get_ast_scope(scope + [len(get_ast_scope(scope)) - 2])
                        set_ast_scope(scope, get_ast_scope(scope)[:-1])
                        append_ast_scope(scope, {
                            'act': 'arrget',
                            'body': [old_stat_place],
                            'args': []
                        })
                        
                        new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                        itt = lex_scope(new_scope, itt, '[]', True)
                elif token["token"] == entr[1]:
                    # scope_checker -= 1
                    # if scope_chnew_scope_setecker == 0:
                    #     break  # break out of the loop, scope end reached
                    break
                elif token["token"] == entr[0]:
                    scope_checker += 1
            elif token["type"] == 'sym':
                # TODO: add support for negative values
                if token["token"] in ['+', '-', '*', '/', '>', '<', '==', '<=', '>=', '&&', '||']:  # operation
                    if is_argp == 2:
                        last_seen_op = -1

                    currarg = get_ast_scope(
                        scope)[len(get_ast_scope(scope)) - 1]
                    set_ast_scope(scope, get_ast_scope(scope)[:-1])
                    append_ast_scope(scope, {
                        'act': 'oper',
                        'args': [
                            currarg
                        ],
                        'val': token["token"]
                    })
                    # print("check next argument itt", itt)
                    new_scope = scope + [len(get_ast_scope(scope)) - 1, 'args']
                    itt = lex_scope(new_scope, itt, '()',
                                    True if is_argp == 0 else is_argp)
                    # itt -= 1
                    # print("Ended operation itt", itt, "char", tokens[itt]["token"])
            if is_argp != 0:
                print("CHECK TOKEN IS", tokens[itt]["token"], token["token"],
                      "ITT", itt, "is_argp", is_argp, "entr", entr)
                if tokens[itt]["token"] in [",", ".", ")"]:
                    break  # argument parsing done
            last_seen_op += 1
            if is_argp == 2:
                incr_itt()
                itt -= 1
                print("Should I stop varset? itt", itt, "lastseen",
                      last_seen_op, "nexttok", tokens[itt + 1]["token"])
                if tokens[itt + 1]["token"] not in ['+', '-', '*', '/', '>', '<', '==', '<=', '>=', '&&', '||'] and tokens[itt]["token"] not in ['+', '-', '*', '/', '>', '<', '==', '<=', '>=', '&&', '||']:
                    print("stopping")
                    break
        print("END SCOPE =>", scope, "itt", itt,
              "symbol", tokens[itt]["token"])
        return itt

    ti = -1

    tokens = [{'token': '{', 'type': 'bracket'}] + tokens
    tokens.append({'token': '}', 'type': 'bracket'})

    open(save_prefix_comp + "tokens.txt", "w").write("\n".join(["Token: {}\t\t\tType: {}".format(
        x["token"], x["type"]) for x in tokens]))  # debug

    try:
        lex_scope(['body'], ti)
        error_out()
        open(save_prefix_comp + "ast.json", "w").write(json.dumps(
            ast, indent=2, sort_keys=False))  # debug

        # testing different file formats
        open(save_prefix_comp + "program.bson",
             "wb").write(bson.BSON.encode(ast))
        pickle.dump(ast, open(save_prefix_comp + "program.pck", "wb"))
    except Exception as e:
        traceback.print_exc()
        print("Exception has occured:", e)
        print("Dumping ast to ast_err.json")
        open(save_prefix_comp + "ast_err.json", "w").write(json.dumps(
            ast, indent=2, sort_keys=False))  # debug


def run_program(program):
    prog_cnt = pickle.load(open(program, "rb"))
    print("\n\n\nRunning", program)

    DEFAULT_CONSTANTS = {
        'null': None
    }

    def get_ast_scope(scope):
        accumulator = copy.copy(prog_cnt)
        for elem in scope:
            accumulator = accumulator[elem]
        return accumulator

    stop_function = False
    value_function = None

    var_arr = []

    def recursive_run(scope, vars_s={}, multiple_do="=", arg_parse=False):
        nonlocal stop_function
        nonlocal value_function
        instrs = get_ast_scope(scope)
        # print("APPENDING", vars_s, "TO VAR_ARR")
        # debuginfo("from")
        var_arr.append(vars_s)
        return_values = []
        return_value = None

        def set_var(name, value, op='='):
            v_index = get_var(name)["index"]
            if v_index == -1:
                v_index = len(var_arr) - 1
            if op == '=':
                var_arr[v_index][name] = value
            elif op == '+=':
                var_arr[v_index][name] += recursive_run(scope + [i, 'args'])
            elif op == '-=':
                var_arr[v_index][name] -= recursive_run(scope + [i, 'args'])
            elif op == '/=':
                var_arr[v_index][name] /= recursive_run(scope + [i, 'args'])
            elif op == '*=':
                var_arr[v_index][name] *= recursive_run(scope + [i, 'args'])
            else:
                var_arr[v_index][name] = recursive_run(
                    scope + [i, 'args'])  # this is an error but who cares

        def get_var(name):
            # print("var_arr", var_arr)
            for i, k in reversed(list(enumerate(var_arr))):
                # print("I:", i, "K", k)
                if name in k:
                    ret = {
                        'value': k[name],
                        'index': i
                    }
                    # print(ret)
                    return ret
            return {
                'value': None,
                'index': -1
            }

        def manage_return_value(value):
            nonlocal return_value
            if return_value != None:
                if multiple_do == '=':
                    return_value = value
                elif multiple_do == '+':
                    return_value += value
                elif multiple_do == '-':
                    return_value -= value
                elif multiple_do == '*':
                    return_value *= value
                elif multiple_do == '/':
                    return_value /= value
                elif multiple_do == '<':
                    return_value = value > return_value
                elif multiple_do == '>':
                    return_value = value < return_value
                elif multiple_do == '==':
                    return_value = value == return_value
                elif multiple_do == '>=':
                    return_value = value <= return_value
                elif multiple_do == '<=':
                    return_value = value >= return_value
                elif multiple_do == '&&':
                    return_value = value and return_value
                elif multiple_do == '||':
                    return_value = value or return_value
            else:
                return_value = value

        for i, instr in enumerate(instrs):
            # print("RUN INSTR", instr, "SCOPE", scope, "I", i, "vars", var_arr)
            if stop_function:
                if len(scope) == 3:
                    stop_function = False
                # explicity set this because we are returning from the function
                return_value = value_function
                break
            if instr["act"] == "vardef":
                # variable definitions return -1 because it is not allowed to chain variable definitions
                set_var(instr["name"], recursive_run(scope + [i, 'args']))
            elif instr["act"] == "varset":
                set_var(instr["name"], recursive_run(
                    scope + [i, 'args']), instr["oper"])
            elif instr["act"] == "const":
                manage_return_value(instr["val"])
            elif instr["act"] == "oper":
                # print("scope", scope, "val", instr["val"])
                manage_return_value(recursive_run(
                    scope + [i, 'args'], multiple_do=instr["val"]))
            elif instr["act"] == "call":
                function_args = recursive_run(
                    scope + [i, 'args'], arg_parse=True)  # 0 is selfarg
                if instr["name"] == "println":
                    print(function_args[0])
                elif instr["name"] == "print":
                    print(function_args[0], end="")
                elif instr["name"] == "fmt":
                    accum_str = function_args[0]
                    for fmt_i in range(1, len(function_args)):
                        accum_str = accum_str.replace(
                            '$' + str(fmt_i - 1), str(function_args[fmt_i]))
                    manage_return_value(accum_str)
                else:  # call non-builtin function
                    args_list = [x["name"]
                                            for x in get_ast_scope(['body', instr["name"], 'args'])]
                    vars_pass = {}
                    for iters, farg in enumerate(args_list):
                        vars_pass[farg] = function_args[iters]
                    manage_return_value(recursive_run(
                        ['body', instr["name"], 'body'], vars_pass))
            elif instr["act"] == "getvar":
                manage_return_value(get_var(instr["name"])["value"])
            elif instr["act"] == "expr":
                manage_return_value(recursive_run(
                    scope + [i, 'val'], arg_parse=True)[0])
            elif instr["act"] == "statement":
                stat_args = recursive_run(scope + [i, 'args'], arg_parse=True)
                if instr["name"] == "if":
                    if stat_args[0]:
                        recursive_run(scope + [i, 'body'])
                elif instr["name"] == "return":
                    stop_function = True
                    value_function = stat_args[0] if len(stat_args) > 0 else None 
                    break
            elif instr["act"] == "arrset":
                manage_return_value(recursive_run(scope + [i, 'args'], arg_parse=True))
            elif instr["act"] == "arrget":
                manage_return_value(recursive_run(scope + [i, 'body'])[recursive_run(scope + [i, 'args'], arg_parse=True)[0]])

            if arg_parse:
                return_values.append(return_value)

        var_arr.pop()
        return return_values if arg_parse else return_value
        
    recursive_run(['body', 'main', 'body'], DEFAULT_CONSTANTS)


if sys.argv[1] == 'test':
    if len(sys.argv) < 3:
        print("Wrong usage")
        exit(-1)
    saveprefix = sys.argv[2]
    programs = os.listdir('tests/')
    if os.path.isdir(saveprefix):
        shutil.rmtree(saveprefix)
    for program in programs:
        compile_program('tests/' + program, saveprefix)
    for program in programs:
        run_program(saveprefix + '/tests/' + program + '/program.pck')
